#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



# types encapsulating arguments and return values of method initialize

mutable struct initialize_args_BMIService <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function initialize_args_BMIService(; kwargs...)
    obj = new(__meta__initialize_args_BMIService, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct initialize_args_BMIService

const __meta__initialize_args_BMIService = meta(initialize_args_BMIService,
  Symbol[:value],
  Type[String],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::initialize_args_BMIService, name::Symbol)
  if name === :value
    return (obj.values[name])::String
  else
    getfield(obj, name)
  end
end

meta(::Type{initialize_args_BMIService}) = __meta__initialize_args_BMIService



mutable struct initialize_result_BMIService <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function initialize_result_BMIService(; kwargs...)
    obj = new(__meta__initialize_result_BMIService, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct initialize_result_BMIService

const __meta__initialize_result_BMIService = meta(initialize_result_BMIService,
  Symbol[:error],
  Type[ModelException],
  Symbol[],
  Int[],
  Dict{Symbol,Any}(:error => ModelException())
)

function Base.getproperty(obj::initialize_result_BMIService, name::Symbol)
  if name === :error
    return (obj.values[name])::ModelException
  else
    getfield(obj, name)
  end
end

meta(::Type{initialize_result_BMIService}) = __meta__initialize_result_BMIService


# types encapsulating arguments and return values of method update

mutable struct update_args_BMIService <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function update_args_BMIService(; kwargs...)
    obj = new(__meta__update_args_BMIService, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct update_args_BMIService

const __meta__update_args_BMIService = meta(update_args_BMIService,
  Symbol[],
  Type[],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

meta(::Type{update_args_BMIService}) = __meta__update_args_BMIService



mutable struct update_result_BMIService <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function update_result_BMIService(; kwargs...)
    obj = new(__meta__update_result_BMIService, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct update_result_BMIService

const __meta__update_result_BMIService = meta(update_result_BMIService,
  Symbol[:error],
  Type[ModelException],
  Symbol[],
  Int[],
  Dict{Symbol,Any}(:error => ModelException())
)

function Base.getproperty(obj::update_result_BMIService, name::Symbol)
  if name === :error
    return (obj.values[name])::ModelException
  else
    getfield(obj, name)
  end
end

meta(::Type{update_result_BMIService}) = __meta__update_result_BMIService




# Processor for BMIService service (to be used in server implementation)
mutable struct BMIServiceProcessor <: TProcessor
  tp::ThriftProcessor
  function BMIServiceProcessor()
    p = new(ThriftProcessor())
    handle(p.tp, ThriftHandler("initialize", _initialize, initialize_args_BMIService, initialize_result_BMIService))
    handle(p.tp, ThriftHandler("update", _update, update_args_BMIService, update_result_BMIService))
    p
  end
end # mutable struct BMIServiceProcessor
function _initialize(inp::initialize_args_BMIService)
  try
    initialize(inp.value)
    return initialize_result_BMIService()
  catch ex
    exret = initialize_result_BMIService()
    isa(ex, ModelException) && (exret.error = ex; return exret)
    rethrow()
  end # try
end #function _initialize
function _update(inp::update_args_BMIService)
  try
    update()
    return update_result_BMIService()
  catch ex
    exret = update_result_BMIService()
    isa(ex, ModelException) && (exret.error = ex; return exret)
    rethrow()
  end # try
end #function _update
process(p::BMIServiceProcessor, inp::TProtocol, outp::TProtocol) = process(p.tp, inp, outp)
distribute(p::BMIServiceProcessor) = distribute(p.tp)


# Server side methods to be defined by user:
# function initialize(value::String)
#     # returns nothing
#     # throws error::ModelException
# function update()
#     # returns nothing
#     # throws error::ModelException


# Client implementation for BMIService service
mutable struct BMIServiceClient <: BMIServiceClientBase
  p::TProtocol
  seqid::Int32
  BMIServiceClient(p::TProtocol) = new(p, 0)
end # mutable struct BMIServiceClient

# Client callable method for initialize
function initialize(c::BMIServiceClientBase, value::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "initialize", Thrift.MessageType.CALL, c.seqid)
  inp = initialize_args_BMIService()
  inp.value = value
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, initialize_result_BMIService())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  #hasproperty(outp, :error) && throw(outp.error)
  nothing
end # function initialize

# Client callable method for update
function update(c::BMIServiceClientBase)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "update", Thrift.MessageType.CALL, c.seqid)
  inp = update_args_BMIService()
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, update_result_BMIService())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  #hasproperty(outp, :error) && throw(outp.error)
  nothing
end # function update

